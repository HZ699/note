20160728
->深入理解流程图,进一步构造函数(明天来)✔
->解决Siftdown算法✔
->阅读C++书籍,了解概念✔
待办事项
1.找真正的房东签安保协议✔
总结
1.父节点与左右节点比较,有4种情况,每种情况的操作基本相同,可以共用一个操作,因此要讨论的是这4种情况的共同性质(而不是分开讨论,
导致代码堆砌难懂)共同性质难看出来,就画图呗
2.存储地址是上面为0x00000000,最下面是0xffffffff,从上到下递增.局部变量进入内存的方式是堆栈式,先入后出.全局变量正好相反
(可能是队列式,先进先出,最先进的放在最上面)
3.指针本质是内存单元的地址(其值是变量在内存单元中第一个字节的地址),指针变量是专门存储内存单元地址的一种变量,
4.指针取得变量值得话,不仅需要值(指向变量第一个字节的内存地址),还需变量类型(决定选取几个字节)
声明列如 int* pa=&i; int*表示pa是整型的指针变量,&i表示i的地址,赋值,
5.&变量名可以得到该变量的内存地址.
6.注意点 
*pa=&b,非法,左边的类型是int,右边的是int*型,不匹配
pa=&x,非法,pa是指向int*型,而&x是float*型
pb=0x3000;非法,不能直接赋字面常量的值
7.指针变量求得对象的值,直接用*指针变量,如*pa表示pa指向的对象的内容,而在声明赋值时是要对象的地址,两者要区分
8.调用成员函数时,可将原本的实参定义为形参,成员函数的形参指针与调用时的类型 两者必须相同,如void square(double * d);调用时square(&d1)一致
这样做的好处是d是指针变量(4个字节表示地址),不直接操作,而是指向调用方的实参值运算,适合用于"大"的对象函数处理.
9.指针的加减运算只有在数组上才有用(因为指针变量的值表示地址,地址的加减运算就是指针指向的位置向上或向下移动n*sizeof(类型变量)的值,
实现数组数值的地址与指针相对应,这是内部操作,理解就行,地址换算有用)
10.数组的存储方式也是先进先出,从上到下,地址递增,a[0]到a[n-1];跟全局变量一样
